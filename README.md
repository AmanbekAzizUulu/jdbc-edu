# Code Explanation

Пробрасывание исключений, как в нашем коде, с помощью `RuntimeException`, имеет свои плюсы и минусы. Давайте разберёмся, почему такой подход может считаться оптимизацией и в каких ситуациях он применяется.

## Код

```java
public static Connection open() {
    try {
        return DriverManager.getConnection(DATABASE_NAME, USER_NAME, PASSWORD);
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}
```

### Объяснение

1. **Упрощение обработки исключений:**
   В оригинальной версии метода `DriverManager.getConnection`, если происходит ошибка, генерируется `SQLException`, который является проверяемым исключением (checked exception). Это значит, что в каждом месте, где вызывается метод `open()`, вам пришлось бы либо обрабатывать это исключение с помощью `try-catch`, либо пробрасывать его дальше по цепочке вызовов через `throws SQLException`.

   Преобразование `SQLException` в `RuntimeException` (непроверяемое исключение) позволяет избежать необходимости явно обрабатывать или пробрасывать исключение. Таким образом, метод `open()` можно использовать без лишних `try-catch` блоков в вызывающем коде. Это делает код более чистым и проще в написании, особенно если вы уверены, что ошибка должна прерывать выполнение программы.

2. **Передача ошибки дальше:**
   Если что-то пошло не так при подключении к базе данных, в большинстве случаев это ошибка, которая не может быть легко исправлена в коде, вызвавшем этот метод. Пробрасывание `RuntimeException` позволяет прекратить выполнение программы и сигнализировать об ошибке на более высоком уровне, что может быть полезно в случае критических ошибок, таких как невозможность подключения к базе данных.

3. **Повышение читаемости:**
   Код становится проще и легче для понимания. Вам не нужно беспокоиться о каждом `SQLException` в вашем коде — все ошибки автоматически "пробрасываются" в виде непроверяемых исключений.

### Минусы такого подхода

1. **Потеря гибкости в обработке:**
   Поскольку исключение превращается в `RuntimeException`, вызывающий код не обязан его обрабатывать. Это может привести к ситуации, когда ошибка останется необработанной, что может усложнить отладку и слежение за ошибками.

2. **Меньше контроля:**
   Когда вы пробрасываете исключение как `RuntimeException`, вы теряете контроль над тем, как оно будет обрабатываться. В некоторых случаях это может привести к неожиданным последствиям.

### Когда использовать

Этот подход полезен в случаях, когда ошибка, как правило, является критической и должна завершить выполнение программы, или когда проверка и обработка исключений в каждом вызове не является необходимой и лишь утяжеляет код.

Итак, такой способ обработки исключений оптимизирует ваш код, делая его чище и проще, но требует осмотрительности и понимания последствий, связанных с тем, что ошибки могут не быть должным образом обработаны.

---

## Скрипт для создания базы данных

`create_flight_repository` - создает базу данных полетов

Слудующие скрипты вставлют данные в соответствующие таблицы

- `insert_into_aircraft_table`
- `insert_into_airport_table`
- `insert_into_flight_table`
- `insert_into_seat_table`
- `insert_into_ticket_table`


---

В ходе изучения темы я буду создавать различные тематические ветки и каждая ветка будет отходить от точки initial commit


---

Colored output to console
- `\033[0m` — Сброс цвета и форматирования.
- `\033[0;31m` — Красный цвет.
- `\033[0;32m` — Зеленый цвет.
- `\033[0;33m` — Желтый цвет.
- `\033[0;34m` — Синий цвет.

---

Давайте разберем, как работает этот код:

```java
PropertiesUtil.class.getClassLoader().getResourceAsStream("application.properties")
```

### 1. `PropertiesUtil.class`
Этот элемент кода возвращает объект `Class`, представляющий класс `PropertiesUtil`. Используя этот объект, можно получить доступ к метаданным класса, а также к методам для работы с загрузкой ресурсов и загрузчиком классов.

### 2. `getClassLoader()`
Метод `getClassLoader()` возвращает загрузчик классов (`ClassLoader`), который загрузил данный класс. В этом случае, `PropertiesUtil.class.getClassLoader()` возвращает загрузчик классов, который загрузил класс `PropertiesUtil`.

Загрузчики классов в Java ответственны за загрузку классов и ресурсов (например, файлов) в память JVM. В зависимости от среды исполнения (например, веб-сервер, десктопное приложение), могут использоваться различные загрузчики классов.

### 3. `getResourceAsStream("application.properties")`
Этот метод используется для загрузки ресурса (в данном случае файла `application.properties`) как потока ввода (`InputStream`).

#### Как это работает:
- Метод `getResourceAsStream()` ищет ресурс (например, файл) с указанным именем на пути к классам, доступном этому загрузчику классов.
- Если ресурс найден, метод возвращает поток ввода (`InputStream`), через который можно прочитать содержимое файла.
- Если ресурс не найден, метод возвращает `null`.

### Общий механизм работы:

1. **Загрузка класса:**
   JVM загрузила класс `PropertiesUtil` с помощью определенного загрузчика классов (`ClassLoader`). Этот загрузчик классов отвечает за поиск и загрузку всех ресурсов, связанных с классом `PropertiesUtil`.

2. **Поиск ресурса:**
   Когда вызывается `getResourceAsStream("application.properties")`, загрузчик классов ищет файл `application.properties` в директориях или JAR-файлах, которые он обрабатывает. Например, если этот файл находится в корне директории `src/main/resources`, то загрузчик классов найдет его там.

3. **Открытие потока:**
   Если файл `application.properties` найден, `getResourceAsStream` возвращает поток ввода (`InputStream`), который можно использовать для чтения содержимого файла.

### Пример использования:

```java
import java.io.InputStream;
import java.util.Properties;

public class PropertiesUtil {

    public static Properties loadProperties() {
        Properties properties = new Properties();

        try (InputStream input = PropertiesUtil.class.getClassLoader().getResourceAsStream("application.properties")) {
            if (input == null) {
                System.out.println("Sorry, unable to find application.properties");
                return null;
            }

            // load a properties file from class path, inside static method
            properties.load(input);

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return properties;
    }
}
```

### Краткое резюме:
Этот код использует загрузчик классов для поиска файла `application.properties` в пути классов. Если файл найден, он возвращается в виде потока ввода, который затем можно использовать для загрузки конфигурации в объект `Properties`. Это обычная практика для работы с конфигурационными файлами, размещенными в ресурсах приложения.


---

Этот код небезопасен, потому что он уязвим для SQL-инъекций. Давайте рассмотрим подробнее:

### Проблема: Уязвимость к SQL-инъекции
В коде используется метод `String.formatted()` для вставки значения переменной `flightId` непосредственно в SQL-запрос:

```java
String select_ticket_by_flight_id = """
    select
        id
    from
        ticket
    where
        flight_id = %s
""".formatted(flightId);
```

Если переменная `flightId` содержит вредоносный SQL-код, этот код будет вставлен напрямую в запрос, что может привести к SQL-инъекции. Например, если злоумышленник передаст в `flightId` следующую строку:

```java
"1 OR 1=1"
```

То сформированный запрос будет выглядеть так:

```sql
SELECT id FROM ticket WHERE flight_id = 1 OR 1=1
```

Этот запрос вернет все строки из таблицы `ticket`, что не является ожидаемым поведением.

### Безопасное решение: Использование PreparedStatement
Чтобы избежать SQL-инъекций, следует использовать подготовленные выражения (`PreparedStatement`). В этом случае параметры запроса передаются отдельно от самого SQL-кода, что предотвращает возможность их интерпретации как SQL-команды.

Вот как можно переписать ваш код, используя `PreparedStatement`:

```java
private static List<Long> getTicketsByFlightId(String flightId) throws SQLException {
    List<Long> selectedId = new ArrayList<Long>();
    String select_ticket_by_flight_id = """
        select
            id
        from
            ticket
        where
            flight_id = ?
    """;
    try (Connection connection = ConnectionManager.open();
         PreparedStatement preparedStatement = connection.prepareStatement(select_ticket_by_flight_id)) {
        preparedStatement.setString(1, flightId); // Устанавливаем значение flightId как параметр
        ResultSet resultSet = preparedStatement.executeQuery();

        while (resultSet.next()) {
            selectedId.add(resultSet.getObject(1, Long.class)); // На случай, если resultSet будет содержать null
        }
    }
    return selectedId;
}
```

### Почему это решение безопасно:
1. **Параметризованный запрос:** Значение `flightId` передается в запрос как параметр, и база данных гарантирует, что оно будет интерпретироваться как строковое значение, а не как часть SQL-кода.

2. **Защита от SQL-инъекций:** Даже если злоумышленник попытается передать вредоносный код в `flightId`, он будет интерпретирован как обычная строка, что предотвращает SQL-инъекцию.

Таким образом, использование `PreparedStatement` вместо конкатенации строк для создания SQL-запросов делает ваш код более безопасным и устойчивым к атакам SQL-инъекций.

---


Для избежания SQL-инъекций в JDBC не рекомендуется использовать методы, которые позволяют напрямую вставлять пользовательский ввод в SQL-запросы. Основные методы, которых следует избегать:

### 1. **Statement.executeQuery() и Statement.executeUpdate()**
   - Эти методы позволяют выполнять SQL-запросы, создавая строку запроса, которая включает в себя пользовательский ввод напрямую. Это делает их уязвимыми для SQL-инъекций, если пользовательский ввод не экранирован или не проверен должным образом.
   - **Пример опасного использования:**
     ```java
     Statement statement = connection.createStatement();
     String query = "SELECT * FROM users WHERE username = '" + userInput + "' AND password = '" + passwordInput + "'";
     ResultSet resultSet = statement.executeQuery(query);
     ```
   - В этом примере злоумышленник может вставить SQL-код в переменные `userInput` или `passwordInput`, что приведет к SQL-инъекции.

### 2. **Statement.execute()**
   - Метод `execute()` также позволяет выполнять любые SQL-запросы, включая `SELECT`, `INSERT`, `UPDATE`, `DELETE`, и т.д. Если запрос создается с использованием строковой конкатенации и пользовательского ввода, то это представляет аналогичный риск SQL-инъекции.
   - **Пример опасного использования:**
     ```java
     Statement statement = connection.createStatement();
     String query = "DELETE FROM users WHERE user_id = " + userInput;
     statement.execute(query);
     ```
   - Если `userInput` содержит вредоносный код, то это может привести к удалению всех пользователей или другим нежелательным последствиям.

### 3. **Statement.addBatch()**
   - Метод `addBatch()` позволяет добавлять несколько SQL-команд в пакет для последующего выполнения. Если SQL-команды в пакете формируются с использованием строковой конкатенации и пользовательского ввода, то это также создает риск SQL-инъекций.
   - **Пример опасного использования:**
     ```java
     Statement statement = connection.createStatement();
     String query1 = "INSERT INTO users (username, password) VALUES ('" + userInput1 + "', '" + passwordInput1 + "')";
     String query2 = "INSERT INTO users (username, password) VALUES ('" + userInput2 + "', '" + passwordInput2 + "')";
     statement.addBatch(query1);
     statement.addBatch(query2);
     statement.executeBatch();
     ```
   - Если пользовательский ввод содержит вредоносный SQL-код, то это может привести к выполнению непредусмотренных запросов.

### **Что использовать вместо этого:**

Для предотвращения SQL-инъекций, рекомендуется использовать **подготовленные выражения (Prepared Statements)**, которые надежно обрабатывают пользовательский ввод и защищают от подобных атак. Подготовленные выражения автоматически экранируют ввод, гарантируя, что он будет интерпретирован как данные, а не как SQL-код.

**Пример безопасного использования PreparedStatement:**

```java
String query = "SELECT * FROM users WHERE username = ? AND password = ?";
PreparedStatement preparedStatement = connection.prepareStatement(query);
preparedStatement.setString(1, userInput);
preparedStatement.setString(2, passwordInput);
ResultSet resultSet = preparedStatement.executeQuery();
```

В этом примере пользовательский ввод `userInput` и `passwordInput` передается в запрос как параметры, что исключает возможность SQL-инъекции.

---

Верно, методы `execute`, `executeQuery`, и `executeUpdate` для `PreparedStatement` не принимают SQL-запрос в качестве параметра, потому что SQL-запрос уже был передан в `PreparedStatement` при его создании. Вот как работают эти методы:

### Методы `PreparedStatement`

1. **`executeQuery()`**
   - Выполняет SQL-запрос, который возвращает результат в виде `ResultSet` (например, SELECT-запросы).
   - Не принимает SQL-запроса как параметра.
   - **Пример:**
     ```java
     String sql = "SELECT * FROM users WHERE username = ?";
     PreparedStatement preparedStatement = connection.prepareStatement(sql);
     preparedStatement.setString(1, "john_doe");
     ResultSet resultSet = preparedStatement.executeQuery();
     ```

2. **`executeUpdate()`**
   - Выполняет SQL-запрос, который изменяет данные в базе данных (например, INSERT, UPDATE, DELETE). Возвращает количество затронутых строк.
   - Не принимает SQL-запроса как параметра.
   - **Пример:**
     ```java
     String sql = "UPDATE users SET password = ? WHERE username = ?";
     PreparedStatement preparedStatement = connection.prepareStatement(sql);
     preparedStatement.setString(1, "new_password");
     preparedStatement.setString(2, "john_doe");
     int affectedRows = preparedStatement.executeUpdate();
     ```

3. **`execute()`**
   - Выполняет SQL-запрос, который может возвращать результат (например, SELECT-запрос) или не возвращать результат (например, INSERT, UPDATE, DELETE). Возвращает `true` если первый результат — это `ResultSet`, и `false` если первый результат — это обновленное количество строк.
   - Не принимает SQL-запроса как параметра.
   - **Пример:**
     ```java
     String sql = "INSERT INTO users (username, password) VALUES (?, ?)";
     PreparedStatement preparedStatement = connection.prepareStatement(sql);
     preparedStatement.setString(1, "john_doe");
     preparedStatement.setString(2, "password123");
     boolean hasResultSet = preparedStatement.execute();
     if (hasResultSet) {
         ResultSet resultSet = preparedStatement.getResultSet();
         // Обработка результата
     } else {
         int affectedRows = preparedStatement.getUpdateCount();
         // Обработка количества затронутых строк
     }
     ```

### Объяснение

1. **`executeQuery()`**:
   - Этот метод используется для выполнения запросов, которые возвращают данные, таких как SELECT-запросы. Результаты запроса возвращаются в виде объекта `ResultSet`.

2. **`executeUpdate()`**:
   - Этот метод используется для выполнения SQL-запросов, которые изменяют данные в базе данных, таких как INSERT, UPDATE, DELETE. Он возвращает количество затронутых строк.

3. **`execute()`**:
   - Этот метод более универсален и может использоваться для выполнения любого SQL-запроса. Он возвращает `true` если результатом выполнения является `ResultSet`, и `false` если результатом является количество затронутых строк.

### Преимущества использования `PreparedStatement`

1. **Безопасность от SQL-инъекций**:
   - `PreparedStatement` защищает от SQL-инъекций, так как SQL-запрос и его параметры передаются отдельно.

2. **Производительность**:
   - Использование `PreparedStatement` может улучшить производительность, так как база данных может оптимизировать выполнение подготовленных запросов и повторно использовать их планы выполнения.

3. **Читаемость и поддерживаемость**:
   - Код становится более читаемым и поддерживаемым, поскольку параметры устанавливаются через методы `setXXX` вместо динамического формирования строк SQL-запросов.

Использование `PreparedStatement` является хорошей практикой в JDBC для безопасного и эффективного выполнения SQL-запросов.

---

`ResultSet` и параметр `fetchSize` тесно связаны, поскольку `fetchSize` определяет, как `ResultSet` будет загружать и обрабатывать данные из базы данных. Понимание их взаимодействия важно для оптимизации работы с большими наборами данных.

### Как `ResultSet` использует `fetchSize`

1. **Определение `fetchSize`:**
   - `fetchSize` — это параметр, который указывает количество строк, которые драйвер JDBC должен извлечь из базы данных за одно обращение, когда вы итеративно проходите через `ResultSet`.

2. **Пример использования:**
   ```java
   Statement statement = connection.createStatement();
   statement.setFetchSize(100); // Устанавливаем fetchSize на 100 строк
   ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table");
   while (resultSet.next()) {
       // Обработка строки
       int id = resultSet.getInt("id");
       String data = resultSet.getString("data");
       System.out.println("ID: " + id + ", Data: " + data);
   }
   resultSet.close();
   statement.close();
   ```

3. **Работа с `fetchSize` в `ResultSet`:**
   - Когда вы вызываете метод `next()` на объекте `ResultSet`, драйвер JDBC проверяет, есть ли еще необработанные строки в текущем пакете (определяемом `fetchSize`). Если строки закончились, драйвер выполняет новое обращение к базе данных для извлечения следующего пакета строк.
   - Если вы установили `fetchSize` на 100, то при первом обращении к базе данных будет загружено 100 строк. Пока вы не обработаете все эти строки, новое обращение к базе данных не произойдет.

4. **Оптимизация производительности:**
   - Установка `fetchSize` может значительно улучшить производительность при работе с большими объемами данных. Вместо того чтобы обращаться к базе данных за каждой строкой, драйвер извлекает сразу несколько строк, что снижает количество сетевых запросов и уменьшает нагрузку на базу данных.
   - Например, если `fetchSize` установлен на 1000, а запрос возвращает 10 000 строк, потребуется всего 10 обращений к базе данных, а не 10 000.

5. **Гибкость настройки:**
   - `fetchSize` можно устанавливать для каждого запроса отдельно, что позволяет адаптировать его значение в зависимости от конкретных условий и объема данных.

6. **Особенности и поддержка драйверами:**
   - Не все JDBC драйверы поддерживают настройку `fetchSize`, и поведение может отличаться в зависимости от драйвера. Некоторые драйверы могут игнорировать этот параметр или использовать его по-своему.
   - Например, для некоторых баз данных (таких как Oracle) `fetchSize` может быть особенно полезным при работе с большими наборами данных.

7. **Связь с памятью:**
   - Хотя увеличение `fetchSize` уменьшает количество сетевых обращений, оно также увеличивает использование памяти, поскольку большее количество строк будет загружено в память за один раз. Поэтому важно выбрать оптимальное значение, соответствующее возможностям вашей системы.

### Пример использования `ResultSet` с `fetchSize`

Предположим, у вас есть таблица `large_table`, содержащая миллионы записей. В этом случае настройка `fetchSize` может помочь избежать проблем с производительностью:

```java
try (Connection connection = DriverManager.getConnection(url, user, password);
     Statement statement = connection.createStatement()) {

    // Устанавливаем размер выборки в 500 строк
    statement.setFetchSize(500);

    try (ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table")) {
        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String data = resultSet.getString("data");
            System.out.println("ID: " + id + ", Data: " + data);
        }
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

### Заключение

Параметр `fetchSize` — это важный инструмент для управления производительностью при работе с `ResultSet`, особенно при обработке больших объемов данных. Установив его правильно, вы можете значительно уменьшить количество сетевых запросов и оптимизировать использование памяти, что приведет к улучшению общей производительности вашего приложения.

---

Параметр `query timeout` (таймаут выполнения запроса) в JDBC задает максимальное время, в течение которого SQL-запрос может выполняться до того, как драйвер прервет его выполнение. Это полезно для предотвращения долгих или бесконечных операций, которые могут повлиять на производительность и стабильность приложения.

### Основные аспекты `query timeout`

1. **Задача и необходимость:**
   - В некоторых случаях SQL-запрос может зависнуть или выполняться слишком долго (например, из-за блокировок, больших объемов данных или неэффективных запросов). Установка таймаута позволяет завершить такие операции и избежать долгого ожидания.

2. **Установка `query timeout`:**
   - Таймаут запроса можно установить с помощью метода `setQueryTimeout(int seconds)` на объекте `Statement` или его производных (`PreparedStatement`, `CallableStatement`).
   - Время таймаута задается в секундах. Если запрос выполняется дольше указанного времени, JDBC-драйвер выбрасывает исключение `SQLTimeoutException`.
   - Пример установки таймаута:
     ```java
     Statement statement = connection.createStatement();
     statement.setQueryTimeout(30); // Устанавливаем таймаут в 30 секунд

     ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table");
     while (resultSet.next()) {
         // Обработка данных
     }
     resultSet.close();
     statement.close();
     ```

3. **Поведение при истечении времени:**
   - Если запрос превышает заданное время выполнения, JDBC-драйвер прерывает его выполнение и генерирует `SQLTimeoutException`.
   - Пример обработки исключения:
     ```java
     try {
         Statement statement = connection.createStatement();
         statement.setQueryTimeout(30); // Таймаут в 30 секунд
         ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table");

         while (resultSet.next()) {
             // Обработка данных
         }

         resultSet.close();
         statement.close();
     } catch (SQLTimeoutException e) {
         System.out.println("Запрос превысил время выполнения: " + e.getMessage());
     } catch (SQLException e) {
         e.printStackTrace();
     }
     ```

4. **Особенности и ограничения:**
   - Таймаут может не всегда срабатывать, так как его поддержка зависит от драйвера JDBC и базы данных. Некоторые базы данных могут игнорировать этот параметр или обрабатывать его по-разному.
   - Таймаут применяется только к времени выполнения запроса. Он не учитывает время, необходимое для передачи данных от базы данных к приложению или обработки результата в `ResultSet`.

5. **Когда использовать `query timeout`:**
   - **Длинные запросы:** Если известно, что некоторые запросы могут выполняться долго, установка таймаута помогает избежать зависания приложения.
   - **Взаимные блокировки:** Если в базе данных возможны взаимные блокировки (deadlocks), таймаут позволяет выявить и прервать такие ситуации.
   - **Непредсказуемые нагрузки:** В условиях непредсказуемой нагрузки на базу данных таймаут помогает контролировать и управлять временем выполнения запросов.

### Пример полного кода с таймаутом

```java
try (Connection connection = DriverManager.getConnection(url, user, password);
     Statement statement = connection.createStatement()) {

    statement.setQueryTimeout(15); // Устанавливаем таймаут в 15 секунд

    try (ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table")) {
        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String data = resultSet.getString("data");
            System.out.println("ID: " + id + ", Data: " + data);
        }
    }

} catch (SQLTimeoutException e) {
    System.out.println("Запрос был прерван из-за превышения времени выполнения.");
} catch (SQLException e) {
    e.printStackTrace();
}
```

### Заключение

`query timeout` — это важный механизм управления временем выполнения SQL-запросов в JDBC, который помогает избегать долгих операций и поддерживать стабильность приложения. Используя этот параметр, вы можете контролировать максимальное время выполнения запросов, что особенно полезно при работе с большими данными или в условиях неопределенной нагрузки на базу данных.


---


Параметр `maxRows` в JDBC используется для ограничения количества строк, возвращаемых результатом SQL-запроса. Он устанавливает максимальное количество строк, которые могут быть прочитаны из `ResultSet`. Этот параметр полезен, когда нужно ограничить объем данных, обрабатываемых приложением, особенно при работе с большими наборами данных.

### Основные аспекты `maxRows`

1. **Задача и необходимость:**
   - `maxRows` позволяет указать максимальное количество строк, которое должно быть возвращено запросом, независимо от общего числа строк, соответствующих критериям запроса.
   - Это может быть полезно, если вам нужно ограничить количество данных, которые ваше приложение загружает и обрабатывает, чтобы избежать перегрузки памяти или улучшить производительность.

2. **Установка `maxRows`:**
   - Значение `maxRows` устанавливается с помощью метода `setMaxRows(int max)` на объекте `Statement`, `PreparedStatement` или `CallableStatement`.
   - Пример установки `maxRows`:
     ```java
     Statement statement = connection.createStatement();
     statement.setMaxRows(100); // Ограничиваем количество строк 100

     ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table");
     while (resultSet.next()) {
         int id = resultSet.getInt("id");
         String data = resultSet.getString("data");
         System.out.println("ID: " + id + ", Data: " + data);
     }
     resultSet.close();
     statement.close();
     ```

3. **Поведение при использовании `maxRows`:**
   - Если значение `maxRows` установлено, драйвер JDBC завершит чтение строк после достижения указанного предела, и `ResultSet` больше не будет содержать дополнительные строки.
   - Например, если запрос возвращает 1000 строк, но `maxRows` установлен на 100, то `ResultSet` будет содержать только первые 100 строк.

4. **Особенности и ограничения:**
   - `maxRows` не изменяет сам SQL-запрос, а только ограничивает количество строк, которые фактически будут доступны через `ResultSet`.
   - Если `maxRows` установлено на значение `0`, это означает, что лимит строк отсутствует, и все строки будут возвращены.
   - Некоторые драйверы и базы данных могут поддерживать аналогичное поведение через SQL-клавиши, такие как `LIMIT` в MySQL или `ROWNUM` в Oracle, но `maxRows` предоставляет независимый от базы данных способ ограничения результатов.

5. **Когда использовать `maxRows`:**
   - **Пагинация:** Если вам нужно реализовать пагинацию (разбиение на страницы), вы можете использовать `maxRows` в сочетании с различными смещениями (например, через `OFFSET` в SQL) для получения нужных данных.
   - **Оптимизация производительности:** Когда требуется ограничить объем данных, передаваемых в приложение, чтобы избежать чрезмерного использования памяти или ресурсов.
   - **Тестирование:** Для тестирования запросов или приложений с небольшими наборами данных, ограничив их размер.

### Пример полного кода с `maxRows`

```java
try (Connection connection = DriverManager.getConnection(url, user, password);
     Statement statement = connection.createStatement()) {

    statement.setMaxRows(50); // Ограничиваем количество строк до 50

    try (ResultSet resultSet = statement.executeQuery("SELECT * FROM large_table")) {
        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String data = resultSet.getString("data");
            System.out.println("ID: " + id + ", Data: " + data);
        }
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

### Взаимодействие с другими параметрами

- **`fetchSize` и `maxRows`:** Эти два параметра могут использоваться совместно, чтобы эффективно управлять загрузкой данных. Например, вы можете установить `maxRows` для ограничения общего количества строк, и `fetchSize` для управления количеством строк, загружаемых за один раз.
- **SQL-конструкции:** Если вы используете конструкции `LIMIT` или `TOP` в SQL-запросе, это может быть более производительно, так как в этом случае база данных сразу вернет ограниченное количество строк.

### Заключение

`maxRows` — это простой, но эффективный механизм управления объемом данных, возвращаемых запросом в JDBC. Он позволяет ограничить количество строк в `ResultSet`, что может быть полезно для оптимизации производительности приложения и управления использованием ресурсов.
